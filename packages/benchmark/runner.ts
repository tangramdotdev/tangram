import { randomBytes } from "node:crypto";
import { mkdir } from "node:fs/promises";
import { normalize } from "node:path";
import { readableStreamToText } from "bun";

/** Toplevel function. Reads arguments and runs requested benchmarks. */
let entrypoint = async () => {
	let args = Bun.argv;

	let requestedBenchmarks = args.slice(2);
	if (
		requestedBenchmarks.length === 0 ||
		requestedBenchmarks.some((b) => b === "all")
	) {
		requestedBenchmarks = Object.keys(definedBenchmarks);
	}

	// Run the requested benchmarks.
	let entries: Array<LogEntry> = [];
	for (let benchmark of requestedBenchmarks) {
		if (benchmark in definedBenchmarks) {
			entries.push(await definedBenchmarks[benchmark]());
		} else {
			throw new Error(`Unknown benchmark: ${benchmark}`);
		}
	}
	let result: Result = { entries };
	console.log(JSON.stringify(result, null, 2));
};

/** Test baseline speed of tarring and hashing a large directory against `tg checkin`. */
let checkin = async (): Promise<LogEntry> => {
	let workDir = await createTempDir();
	// Create a directory with 100 files of 4MB each.
	let randomDir = await populateRandomDir(workDir, 100, 4096 * 1024);

	// Run the benchmarks.
	let warmup = 2;
	let runs = 5;
	let output = emptyOutput;

	let tarOutput = await tar_b3sum_dev_null(randomDir, warmup, runs);
	output.results.push(tarOutput.results[0]);
	let tgOutput = await benchmarkTgOneShot(`checkin ${randomDir}`, warmup, runs);
	output.results.push(tgOutput.results[0]);

	// Clean up the work dir.
	await rmrf(workDir);

	// Produce entry.
	let benchmark = "checkin";
	let timestamp = new Date().toISOString();
	return { ...output, benchmark, timestamp };
};

/** Tar a directory, hash it with blake3, and write to /dev/null. */
let tar_b3sum_dev_null = async (dir: string, warmup: number, runs: number) => {
	// NOTE - this doesn't work yet. See https://github.com/oven-sh/bun/issues/8049
	// let tarProc = Bun.spawn(["tar", "cf", "-", randomDir]);
	// let b3proc = Bun.spawn(["b3sum", "--", "-"], { stdin: tarProc.stdout });
	let script = `tar -cf - ${dir} | b3sum > /dev/null`;
	let { stdout } = Bun.spawn([
		"hyperfine",
		"--warmup",
		`${warmup}`,
		"--runs",
		`${runs}`,
		"--export-json",
		"-",
		script,
	]);
	let result = await readableStreamToText(stdout);
	return parseHyperfineOutput(result);
};

/** Spawn a server with its own root dir, run a single command, kill server. */
let benchmarkTgOneShot = async (
	command: string,
	warmup: number,
	runs: number,
) => {
	let tangramPath = await createTempDir();
	let url = `unix:${tangramPath}/socket`;

	let script = `
		tg server run --path ${tangramPath} &>/dev/null &
		pid=$!
		sleep 1
		hyperfine                                       \
			--warmup ${warmup}                            \
			--runs ${runs}                                \
			--prepare "tg --url ${url} clean && sync"     \
		 	--export-json -                               \
			"tg --url ${url} ${command}"
		kill $pid &>/dev/null
		umount ${tangramPath}/artifacts
		sync
	`;

	let { stdout } = Bun.spawn(["sh", "-eu", "-c", script]);
	let result = await readableStreamToText(stdout);
	await rmrf(tangramPath);
	return parseHyperfineOutput(result);
};

/** All currently defined benchmarks. */
let definedBenchmarks: Record<string, () => Promise<LogEntry>> = {
	checkin: checkin,
};

/** Parse the output from a hyperfine invocation. */
let parseHyperfineOutput = (json: string): HyperfineOutput => {
	// Extract JSON from the hyperfine output.
	let startIndex = json.indexOf("{");
	let endIndex = json.lastIndexOf("}");
	let jsonString = json.substring(startIndex, endIndex + 1);
	return JSON.parse(jsonString);
};

type HyperfineOutput = {
	results: Array<{
		command: string;
		mean: number;
		stddev: number;
		median: number;
		user: number;
		system: number;
		min: number;
		max: number;
		times: number[];
		exit_codes: number[];
	}>;
};

type LogEntry = HyperfineOutput & {
	benchmark: string;
	timestamp: string;
};

type Result = {
	entries: LogEntry[];
};

/** Create a tempdir, returning the path. */
let createTempDir = async (): Promise<string> => {
	let { stdout } = Bun.spawn(["mktemp", "-d"]);
	let path = (await readableStreamToText(stdout)).trim();
	return path;
};

/** Empty hyperfine output for combining multiple runs. */
let emptyOutput: HyperfineOutput = {
	results: [],
};

/** Create a directory in the given parent directory with num_files files of size bytes_per_file each, filled with randomly generated bytes. Returns the path of the directory. */
let populateRandomDir = async (
	parent: string,
	num_files: number,
	bytes_per_file: number,
): Promise<string> => {
	let dirname = "random_files";
	let dirpath = `${parent}/${dirname}`;
	await mkdir(dirpath);

	let createRandomFile = async (i: number) => {
		let filename = `file_${i}`;
		let filepath = `${dirpath}/${filename}`;
		let randomContents = randomBytes(bytes_per_file);
		await Bun.write(filepath, randomContents.toString());
	};

	let fileCreationPromises: Array<Promise<void>> = [];
	for (let i = 0; i < num_files; i++) {
		fileCreationPromises.push(createRandomFile(i));
	}
	await Promise.all(fileCreationPromises);

	return dirpath;
};

/** Remove a directory. */
let rmrf = async (path: string) => {
	let proc = Bun.spawn(["rm", "-rf", path]);
	await proc.exited;
};

// Run the main function.
await entrypoint();
